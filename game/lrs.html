<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>高级狼人杀游戏</title>
    <style>
        /* 界面样式优化 */
        .container {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            padding: 20px;
            background: #1a1a1a;
            color: #fff;
            min-height: 100vh;
        }
        #playerPanel {
            border: 2px solid #2d2d2d;
            padding: 15px;
            border-radius: 8px;
        }
        .player-card {
            background: #333;
            margin: 10px;
            padding: 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: 0.3s;
        }
        .player-card:hover {
            background: #444;
        }
        #gameLog {
            background: #222;
            height: 400px;
            overflow-y: auto;
            padding: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="playerPanel"></div>
        <div id="controlPanel">
            <h3>游戏阶段：<span id="phaseDisplay">准备中</span></h3>
            <div id="actionButtons"></div>
            <div id="gameLog"></div>
        </div>
    </div>

    <script>
        // ================= 游戏核心类定义 =================
        class Game {
            constructor() {
                this.players = [];
                this.phase = 'night'; // night/day
                this.currentStage = 'wolf'; // wolf/witch/prophet
                this.killedTonight = [];
                this.gameLog = [];
                this.initRoles();
            }

            initRoles() {
                const roles = [
                    { role: '狼人', camp: 'wolf', count: 2 },
                    { role: '预言家', camp: 'human', count: 1 },
                    { role: '女巫', camp: 'human', count: 1 },
                    { role: '猎人', camp: 'human', count: 1 },
                    { role: '平民', camp: 'human', count: 4 }
                ];
                
                roles.forEach(r => {
                    for (let i = 0; i < r.count; i++) {
                        this.players.push({
                            id: this.players.length + 1,
                            role: r.role,
                            camp: r.camp,
                            alive: true,
                            poisoned: false,
                            protected: false
                        });
                    }
                });
                this.players = this.shuffleArray(this.players);:ml-citation{ref="2,6" data="citationList"}
            }

            shuffleArray(arr) {
                return arr.sort(() => Math.random() - 0.5);
            }

            // ================= 夜晚阶段逻辑 =================
            wolfAction(targetId) {
                const target = this.players.find(p => p.id === targetId);
                if (target.protected) {
                    this.addLog(`守卫保护了 ${targetId} 号玩家`);
                    return;
                }
                this.killedTonight.push(targetId);
                this.addLog(`狼人选择击杀 ${targetId} 号玩家`);:ml-citation{ref="3,7" data="citationList"}
            }

            witchAction(type, targetId = null) {
                const witch = this.players.find(p => p.role === '女巫');
                if (type === 'antidote') {
                    witch.antidote = false;
                    this.killedTonight = [];
                    this.addLog(`女巫使用解药救活了 ${targetId} 号`);
                } else if (type === 'poison') {
                    witch.poison = false;
                    this.players.find(p => p.id === targetId).alive = false;
                    this.addLog(`女巫毒杀了 ${targetId} 号玩家`);:ml-citation{ref="5,7" data="citationList"}
                }
            }

            prophetAction(targetId) {
                const target = this.players.find(p => p.id === targetId);
                this.addLog(`${targetId} 号玩家属于 ${target.camp} 阵营`);:ml-citation{ref="6,7" data="citationList"}
            }

            // ================= 白天阶段逻辑 =================
            startVoting() {
                this.phase = 'day';
                this.addLog("开始投票环节");
                this.renderPlayers();
            }

            processVotes() {
                const votes = {};
                this.players.forEach(p => {
                    if (p.alive && p.voteTarget) {
                        votes[p.voteTarget] = (votes[p.voteTarget] || 0) + 1;
                    }
                });
                const maxVotes = Math.max(...Object.values(votes));
                const targets = Object.keys(votes).filter(k => votes[k] === maxVotes);
                
                targets.forEach(t => {
                    const player = this.players.find(p => p.id == t);
                    player.alive = false;
                    this.addLog(`${t} 号玩家被投票处决`);
                    if (player.role === '猎人') this.hunterAction(t);:ml-citation{ref="3,7" data="citationList"}
                });
            }

            hunterAction(targetId) {
                const hunter = this.players.find(p => p.id == targetId);
                if (hunter.alive) return;
                this.addLog("猎人发动技能，请选择带走的玩家");
                // 需实现玩家选择逻辑:ml-citation{ref="7" data="citationList"}
            }

            // ================= 辅助方法 =================
            addLog(text) {
                this.gameLog.push(`[${new Date().toLocaleTimeString()}] ${text}`);
                this.renderLog();
            }

            checkGameEnd() {
                const wolves = this.players.filter(p => p.camp === 'wolf' && p.alive);
                const humans = this.players.filter(p => p.camp === 'human' && p.alive);
                if (wolves.length === 0) return 'human';
                if (wolves.length >= humans.length) return 'wolf';
                return null;
            }
        }

        // ================= 界面渲染与交互 =================
        const game = new Game();
        
        function renderPlayers() {
            const container = document.getElementById('playerPanel');
            container.innerHTML = game.players.map(p => `
                <div class="player-card" data-id="${p.id}" 
                     onclick="handlePlayerClick(${p.id})"
                     style="opacity: ${p.alive ? 1 : 0.4}">
                    <span>玩家 ${p.id}</span>
                    <span>${p.alive ? '存活' : '死亡'}</span>
                    ${p.poisoned ? '💀' : ''}
                </div>
            `).join('');:ml-citation{ref="8" data="citationList"}
        }

        function updateControlPanel() {
            document.getElementById('phaseDisplay').textContent = 
                game.phase === 'night' ? '夜晚' : '白天';
            
            const btnPanel = document.getElementById('actionButtons');
            if (game.phase === 'night') {
                let buttons = '';
                if (game.currentStage === 'wolf') {
                    buttons = '<button onclick="nextStage()">狼人行动完成</button>';
                } else if (game.currentStage === 'witch') {
                    buttons = `
                        <button onclick="useAntidote()">使用解药</button>
                        <button onclick="usePoison()">使用毒药</button>
                    `;
                }
                btnPanel.innerHTML = buttons;:ml-citation{ref="7,8" data="citationList"}
            } else {
                btnPanel.innerHTML = '<button onclick="startVoting()">开始投票</button>';
            }
        }

        // ================= 事件处理 =================
        function handlePlayerClick(playerId) {
            if (game.phase === 'night') {
                if (game.currentStage === 'wolf') game.wolfAction(playerId);
                else if (game.currentStage === 'prophet') game.prophetAction(playerId);
            } else {
                const player = game.players.find(p => p.id === playerId);
                if (player.alive) player.voteTarget = playerId;
            }
            renderPlayers();:ml-citation{ref="6,8" data="citationList"}
        }

        function nextStage() {
            const stages = ['wolf', 'witch', 'prophet'];
            const index = stages.indexOf(game.currentStage);
            game.currentStage = stages[index + 1] || 'day';
            updateControlPanel();:ml-citation{ref="7" data="citationList"}
        }

        // ================= 初始化 =================
        renderPlayers();
        updateControlPanel();
    </script>
</body>
</html>
